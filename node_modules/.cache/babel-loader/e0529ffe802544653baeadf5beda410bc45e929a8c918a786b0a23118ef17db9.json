{"ast":null,"code":"import { Contract, ethers } from \"ethers\";\nimport * as chains from \"../constants/chains\";\nimport COINS from \"../constants/coins\";\nconst ROUTER = require(\"../assets/abi/UniswapV2Router02.json\");\nconst ERC20 = require(\"../assets/abi/ERC20.json\");\nconst FACTORY = require(\"../assets/abi/IUniswapV2Factory.json\");\nconst PAIR = require(\"../assets/abi/IUniswapV2Pair.json\");\nexport function getProvider() {\n  return new ethers.providers.Web3Provider(window.ethereum);\n}\nexport function getSigner(provider) {\n  return provider.getSigner();\n}\nexport async function getNetwork(provider) {\n  const network = await provider.getNetwork();\n  return network.chainId;\n}\nexport function getRouter(address, signer) {\n  return new Contract(address, ROUTER.abi, signer);\n}\nexport async function checkNetwork(provider) {\n  const chainId = getNetwork(provider);\n  if (chains.networks.includes(chainId)) {\n    return true;\n  }\n  return false;\n}\nexport function getWeth(address, signer) {\n  return new Contract(address, ERC20.abi, signer);\n}\nexport function getFactory(address, signer) {\n  return new Contract(address, FACTORY.abi, signer);\n}\nexport async function getAccount() {\n  const accounts = await window.ethereum.request({\n    method: \"eth_requestAccounts\"\n  });\n  return accounts[0];\n}\n\n//This function checks if a ERC20 token exists for a given address\n//    `address` - The Ethereum address to be checked\n//    `signer` - The current signer\nexport function doesTokenExist(address, signer) {\n  try {\n    return new Contract(address, ERC20.abi, signer);\n  } catch (err) {\n    return false;\n  }\n}\nexport async function getDecimals(token) {\n  const decimals = await token.decimals().then(result => {\n    return result;\n  }).catch(error => {\n    console.log('No tokenDecimals function for this token, set to 0');\n    return 0;\n  });\n  return decimals;\n}\n\n// This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function getBalanceAndSymbol(accountAddress, address, provider, signer, weth_address, coins) {\n  try {\n    if (address === weth_address) {\n      const balanceRaw = await provider.getBalance(accountAddress);\n      return {\n        balance: ethers.utils.formatEther(balanceRaw),\n        symbol: coins[0].abbr\n      };\n    } else {\n      const token = new Contract(address, ERC20.abi, signer);\n      const tokenDecimals = await getDecimals(token);\n      const balanceRaw = await token.balanceOf(accountAddress);\n      const symbol = await token.symbol();\n      return {\n        balance: balanceRaw * 10 ** -tokenDecimals,\n        symbol: symbol\n      };\n    }\n  } catch (error) {\n    console.log('The getBalanceAndSymbol function had an error!');\n    console.log(error);\n    return false;\n  }\n}\n\n// This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\n// No error handling is done, so any issues can be caught with the use of .catch()\n// To work correctly, there needs to be 7 arguments:\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `amount` - A float or similar number representing the value of address1's token to trade\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `signer` - The current signer\nexport async function swapTokens(address1, address2, amount, routerContract, accountAddress, signer) {\n  const tokens = [address1, address2];\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const tokenDecimals = await getDecimals(token1);\n  const amountIn = ethers.utils.parseUnits(amount, tokenDecimals);\n  const amountOut = await routerContract.callStatic.getAmountsOut(amountIn, tokens);\n  let tx = await token1.approve(routerContract.address, amountIn);\n  await tx.wait();\n  const wethAddress = await routerContract.WETH();\n  if (address1 === wethAddress) {\n    // Eth -> Token\n    await routerContract.swapExactETHForTokens(amountOut[1], tokens, accountAddress, deadline, {\n      value: amountIn\n    });\n  } else if (address2 === wethAddress) {\n    // Token -> Eth\n    await routerContract.swapExactTokensForETH(amountIn, amountOut[1], tokens, accountAddress, deadline);\n  } else {\n    await routerContract.swapExactTokensForTokens(amountIn, amountOut[1], tokens, accountAddress, deadline);\n  }\n}\n\n//This function returns the conversion rate between two token addresses\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\n//    `amountIn` - Amount of the token at address 1 to be swaped from\n//    `routerContract` - The router contract to carry out this swap\nexport async function getAmountOut(address1, address2, amountIn, routerContract, signer) {\n  try {\n    const token1 = new Contract(address1, ERC20.abi, signer);\n    const token1Decimals = await getDecimals(token1);\n    const token2 = new Contract(address2, ERC20.abi, signer);\n    const token2Decimals = await getDecimals(token2);\n    const values_out = await routerContract.getAmountsOut(ethers.utils.parseUnits(String(amountIn), token1Decimals), [address1, address2]);\n    const amount_out = values_out[1] * 10 ** -token2Decimals;\n    console.log('amount out: ', amount_out);\n    return Number(amount_out);\n  } catch {\n    return false;\n  }\n}\n\n// This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\n//    `pair` - The pair contract for the two tokens\nexport async function fetchReserves(address1, address2, pair, signer) {\n  try {\n    // Get decimals for each coin\n    const coin1 = new Contract(address1, ERC20.abi, signer);\n    const coin2 = new Contract(address2, ERC20.abi, signer);\n    const coin1Decimals = await getDecimals(coin1);\n    const coin2Decimals = await getDecimals(coin2);\n\n    // Get reserves\n    const reservesRaw = await pair.getReserves();\n\n    // Put the results in the right order\n    const results = [(await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1], (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0]];\n\n    // Scale each to the right decimal place\n    return [results[0] * 10 ** -coin1Decimals, results[1] * 10 ** -coin2Decimals];\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0];\n  }\n}\nexport async function fetchReservesRaw(address1, address2, pair, signer) {\n  try {\n    // Get decimals for each coin\n    const coin1 = new Contract(address1, ERC20.abi, signer);\n    const coin2 = new Contract(address2, ERC20.abi, signer);\n    // Get reserves\n    const reservesRaw = await pair.getReserves();\n\n    // Put the results in the right order\n    const results = [(await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1], (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0]];\n\n    // Scale each to the right decimal place\n    return results;\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0];\n  }\n}\n// This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `factory` - The current factory\n//    `signer` - The current signer\nexport async function getReserves(address1, address2, factory, signer, accountAddress) {\n  try {\n    const pairAddress = await factory.getPair(address1, address2);\n    const pair = new Contract(pairAddress, PAIR.abi, signer);\n    if (pairAddress !== '0x0000000000000000000000000000000000000000') {\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer);\n      const liquidityTokens_BN = await pair.balanceOf(accountAddress);\n      const liquidityTokens = Number(ethers.utils.formatEther(liquidityTokens_BN));\n      return [reservesRaw[0].toPrecision(6), reservesRaw[1].toPrecision(6), liquidityTokens];\n    } else {\n      console.log(\"no reserves yet\");\n      return [0, 0, 0];\n    }\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0, 0];\n  }\n}","map":{"version":3,"names":["Contract","ethers","chains","COINS","ROUTER","require","ERC20","FACTORY","PAIR","getProvider","providers","Web3Provider","window","ethereum","getSigner","provider","getNetwork","network","chainId","getRouter","address","signer","abi","checkNetwork","networks","includes","getWeth","getFactory","getAccount","accounts","request","method","doesTokenExist","err","getDecimals","token","decimals","then","result","catch","error","console","log","getBalanceAndSymbol","accountAddress","weth_address","coins","balanceRaw","getBalance","balance","utils","formatEther","symbol","abbr","tokenDecimals","balanceOf","swapTokens","address1","address2","amount","routerContract","tokens","time","Math","floor","Date","now","deadline","BigNumber","from","token1","amountIn","parseUnits","amountOut","callStatic","getAmountsOut","tx","approve","wait","wethAddress","WETH","swapExactETHForTokens","value","swapExactTokensForETH","swapExactTokensForTokens","getAmountOut","token1Decimals","token2","token2Decimals","values_out","String","amount_out","Number","fetchReserves","pair","coin1","coin2","coin1Decimals","coin2Decimals","reservesRaw","getReserves","results","token0","fetchReservesRaw","factory","pairAddress","getPair","liquidityTokens_BN","liquidityTokens","toPrecision"],"sources":["/Users/vantwembeke/Github/DogSwap v2/src/utils/ethereumFunctions.js"],"sourcesContent":["import { Contract, ethers } from \"ethers\";\nimport * as chains from \"../constants/chains\";\nimport COINS from \"../constants/coins\";\n\nconst ROUTER = require(\"../assets/abi/UniswapV2Router02.json\");\nconst ERC20 = require(\"../assets/abi/ERC20.json\");\nconst FACTORY = require(\"../assets/abi/IUniswapV2Factory.json\");\nconst PAIR = require(\"../assets/abi/IUniswapV2Pair.json\");\n\nexport function getProvider() {\n  return new ethers.providers.Web3Provider(window.ethereum);\n}\n\nexport function getSigner(provider) {\n  return provider.getSigner();\n}\n\nexport async function getNetwork(provider) {\n  const network = await provider.getNetwork();\n  return network.chainId;\n}\n\nexport function getRouter(address, signer) {\n  return new Contract(address, ROUTER.abi, signer);\n}\n\nexport async function checkNetwork(provider) {\n  const chainId = getNetwork(provider);\n  if (chains.networks.includes(chainId)){\n    return true\n  }\n  return false;\n}\n\nexport function getWeth(address, signer) {\n  return new Contract(address, ERC20.abi, signer);\n}\n\nexport function getFactory(address, signer) {\n  return new Contract(address, FACTORY.abi, signer);\n}\n\nexport async function getAccount() {\n  const accounts = await window.ethereum.request({\n    method: \"eth_requestAccounts\",\n  });\n\n  return accounts[0];\n}\n\n//This function checks if a ERC20 token exists for a given address\n//    `address` - The Ethereum address to be checked\n//    `signer` - The current signer\nexport function doesTokenExist(address, signer) {\n  try {\n    return new Contract(address, ERC20.abi, signer);\n  } catch (err) {\n    return false;\n  }\n}\n\nexport async function getDecimals(token) {\n  const decimals = await token.decimals().then((result) => {\n      return result;\n    }).catch((error) => {\n      console.log('No tokenDecimals function for this token, set to 0');\n      return 0;\n    });\n    return decimals;\n}\n\n// This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function getBalanceAndSymbol(\n  accountAddress,\n  address,\n  provider,\n  signer,\n  weth_address,\n  coins\n) {\n  try {\n    if (address === weth_address) {\n      const balanceRaw = await provider.getBalance(accountAddress);\n\n      return {\n        balance: ethers.utils.formatEther(balanceRaw),\n        symbol: coins[0].abbr,\n      };\n    } else {\n      const token = new Contract(address, ERC20.abi, signer);\n      const tokenDecimals = await getDecimals(token);\n      const balanceRaw = await token.balanceOf(accountAddress);\n      const symbol = await token.symbol();\n\n      return {\n        balance: balanceRaw*10**(-tokenDecimals),\n        symbol: symbol,\n      };\n    }\n  } catch (error) {\n    console.log ('The getBalanceAndSymbol function had an error!');\n    console.log (error)\n    return false;\n  }\n}\n\n// This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\n// No error handling is done, so any issues can be caught with the use of .catch()\n// To work correctly, there needs to be 7 arguments:\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `amount` - A float or similar number representing the value of address1's token to trade\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `signer` - The current signer\nexport async function swapTokens(\n  address1,\n  address2,\n  amount,\n  routerContract,\n  accountAddress,\n  signer\n) {\n  const tokens = [address1, address2];\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const tokenDecimals = await getDecimals(token1);\n  \n  const amountIn = ethers.utils.parseUnits(amount, tokenDecimals);\n  const amountOut = await routerContract.callStatic.getAmountsOut(\n    amountIn,\n    tokens\n  );\n\n  let tx = await token1.approve(routerContract.address, amountIn);\n  await tx.wait()\n  const wethAddress = await routerContract.WETH();\n\n  if (address1 === wethAddress) {\n    // Eth -> Token\n    await routerContract.swapExactETHForTokens(\n      amountOut[1],\n      tokens,\n      accountAddress,\n      deadline,\n      { value: amountIn }\n    );\n  } else if (address2 === wethAddress) {\n    // Token -> Eth\n    await routerContract.swapExactTokensForETH(\n      amountIn,\n      amountOut[1],\n      tokens,\n      accountAddress,\n      deadline\n    );\n  } else {\n    await routerContract.swapExactTokensForTokens(\n      amountIn,\n      amountOut[1],\n      tokens,\n      accountAddress,\n      deadline\n    );\n  }\n}\n\n//This function returns the conversion rate between two token addresses\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\n//    `amountIn` - Amount of the token at address 1 to be swaped from\n//    `routerContract` - The router contract to carry out this swap\nexport async function getAmountOut(\n  address1,\n  address2,\n  amountIn,\n  routerContract,\n  signer\n) {\n  try {\n    const token1 = new Contract(address1, ERC20.abi, signer);\n    const token1Decimals = await getDecimals(token1);\n\n    const token2 = new Contract(address2, ERC20.abi, signer);\n    const token2Decimals = await getDecimals(token2);\n\n    const values_out = await routerContract.getAmountsOut(\n      ethers.utils.parseUnits(String(amountIn), token1Decimals),\n      [address1, address2]\n    );\n    const amount_out = values_out[1]*10**(-token2Decimals);\n    console.log('amount out: ', amount_out)\n    return Number(amount_out);\n  } catch {\n    return false;\n  }\n}\n\n// This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\n//    `pair` - The pair contract for the two tokens\nexport async function fetchReserves(address1, address2, pair, signer) {\n  try {\n\n    // Get decimals for each coin\n    const coin1 = new Contract(address1, ERC20.abi, signer);\n    const coin2 = new Contract(address2, ERC20.abi, signer);\n\n    const coin1Decimals = await getDecimals(coin1);\n    const coin2Decimals = await getDecimals(coin2);\n\n    // Get reserves\n    const reservesRaw = await pair.getReserves();\n\n    // Put the results in the right order\n    const results =  [\n      (await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1],\n      (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0],\n    ];\n\n    // Scale each to the right decimal place\n    return [\n      (results[0]*10**(-coin1Decimals)),\n      (results[1]*10**(-coin2Decimals))\n    ]\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0];\n  }\n}\nexport async function fetchReservesRaw(address1, address2, pair, signer) {\n  try {\n\n    // Get decimals for each coin\n    const coin1 = new Contract(address1, ERC20.abi, signer);\n    const coin2 = new Contract(address2, ERC20.abi, signer);\n    // Get reserves\n    const reservesRaw = await pair.getReserves();\n\n    // Put the results in the right order\n    const results =  [\n      (await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1],\n      (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0],\n    ];\n\n    // Scale each to the right decimal place\n    return results;\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0];\n  }\n}\n// This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `factory` - The current factory\n//    `signer` - The current signer\nexport async function getReserves(\n  address1,\n  address2,\n  factory,\n  signer,\n  accountAddress\n) {\n  try {\n    const pairAddress = await factory.getPair(address1, address2);\n    const pair = new Contract(pairAddress, PAIR.abi, signer);\n  \n    if (pairAddress !== '0x0000000000000000000000000000000000000000'){\n  \n      const reservesRaw = await fetchReserves(address1, address2, pair, signer);\n      const liquidityTokens_BN = await pair.balanceOf(accountAddress);\n      const liquidityTokens = Number(\n        ethers.utils.formatEther(liquidityTokens_BN)\n      );\n    \n      return [\n        reservesRaw[0].toPrecision(6),\n        reservesRaw[1].toPrecision(6),\n        liquidityTokens,\n      ];\n    } else {\n      console.log(\"no reserves yet\");\n      return [0,0,0];\n    }\n  }catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0, 0];\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}